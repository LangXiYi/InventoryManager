# InventoryManager

![画板](https://cdn.nlark.com/yuque/0/2025/jpeg/35300344/1755677126007-00d3787b-ad4f-4c34-afab-b6e809f3fb76.jpeg)

本系统区别于传统的结构体库存系统，采用复制子对象构建库存。上方思维导图表示的是本库存系统最基本的单元，容器与物品的关系由本系统维护，用户可以根据项目需求扩展容器功能模块，为物品添加独特的定义以及物品的表现形式。

**优点：**

1. 使用对象构建物品实例，扩展性好，具有面向对象的优点
2. 继承自UObject，支持蓝图系统
3. 封装容器与物品的关系
4. 组合优于继承，拆分容器功能为各个子模块，具有更好的扩展性以及自由度
5. 将物品的表现形式从容器与物品的关系中拆分
6. 组合优于继承，拆分物品定义为多个独立片段，具有更好的扩展性以及自由度

**缺点：**

1. 创建对象具有固定开销不可避免，且多人模式下会占据更多带宽

## 容器
容器这个一概念被拆分，实际容器的功能由多个子模块组成，各个模块间相对独立。可以通过数据资产（InvSys_InventoryObjectContent）对容器进行组合。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755675690387-eb85cf8d-ae8c-48d3-875a-289c6ec42027.png)

如上图所示的内容为背包容器，其内部包含三个模块：显示模块、装备模块、容器模块，分别对应该模块的显示、装备、存储物品等功能。使用模块化的容器可以在开发过程中更快的实现对某一功能的修改且不会影响其他内容。

例如：新增一个口袋容器，该容器不需要装备就会为玩家提供储存物品的网格。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755675991279-e4668e63-329c-45a4-9e9b-0a419dc22508.png)

解决方案：只需要将装备模块删除，同时修改显示模块与容器模块的内容即可。

注意：你可以根据实际需要自行扩展模块类型。如上述内容中的容器模块皆是为了适配网格背包进行扩展的容器模块。

## 物品
物品分别由两部分组成，分别为物品的定义、物品的实例，其中物品的定义采用片段的方式存储，而物品实例则是由UObject组成。

### 物品实例
物品实例由UObject组成，通过复制子对象实现多人模式的支持，相较于使用结构体存储物品实例，使用对象的优点在于扩展方便、支持蓝图等等，但使用UObject进行网络传输必然无法避免对象创建的性能损耗以及更大的网络带宽。

此函数为容器模块下维护复制子对象网络连接的处理函数，主要针对未做修改的对象进行判断，只为已被标记为脏的物品实例进行复制。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755676677906-25e4f018-5561-4a11-b68b-8983d45bcfad.png)

#### 表现形式
传统游戏开发中，物品存在多种表现形式，这里以最传统的网格背包举例，物品在背包中大致由X、Y决定位置，而在使用结构体开发时就意味着在存储到容器的数据中必然携带这组数据，它与容器的关系是不可拆分的，什么样的结构体就意味着什么样的容器。而采用UObject的方式则不同，容器中存储的是指针而非实际数据，你可以通过继承创建出多种多样的物品实例，容器与物品表现形式的脱钩使得物品于容器之间的关系更加简单。这就让通用容器有了用武之地，同时本项目采用的模块化容器使得特化容器更为方便。

例如道具演示视频中出现的三种特殊物品：食物、药水、车钥匙等就是通过继承扩展出来的独特的物品实例，并在蓝图或C++中定义了它们各自的使用逻辑。

**自定义物品如何通过通用容器存储？**

1、在传递物品实例至容器前提前设置对象的属性（×） 

2、通过可变参数列表传递需要修改的属性（√）

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755677847889-b90d7064-e72a-4b92-9e27-64cc7204b546.png)

### 物品定义
物品的定义使用片段式定义，使用该方式定义物品并于物品实例对象向结合能够产生奇妙的化学反应。

例如食物道具，在最初我只为其添加了新鲜度属性，后来我希望在使用该道具会为玩家增加多少饱食度。

为此我只需要在食物的物品定义中额外创建一个食物片段，并在其内部增加了一个RuntimeCurve属性，然后将这一片段加入物品定义内并编辑好不同新鲜度对应的不同饱食度。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755758516538-d71a0e0b-4647-4e64-9271-4a217c308721.png)

打开食物的物品实例蓝图，重写UseItemInstance函数，然后通过FindFragment即可找到物品定义中的这一食物片段，并读取到对应的饱食度。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755758543907-11493086-6fd5-4162-93d9-f7e21616479f.png)

优点：在于物品在针对不需要的属性时可以移除某个片段，减少内存占用。

缺点：无法批量编辑，每个物品都需要手动填写数据。

![](https://cdn.nlark.com/yuque/0/2025/png/35300344/1755678216999-0dd90a88-efe8-4d75-b7da-fcd4001dab26.png)



